# Getting Started 
Gu is fundamentally a library built to handle view rendering, nothing more nor less.
When creating Gu, my main focus was on creating a solution that did not bind itself 
tightly to the perculiarities of either the frontend or backend, but allow each content to 
be renderable regardless of where it is loaded. 

The concepts in Gu are practially simple and rely majorly on a functional and interface based system,
where the structures which define the markup to be rendered are combined functionally and components 
are required to match/implement specific interfaces to enable specific features eg Reaction for page/view update.

Gu is in no way a Flux-like framework or library, nor does it provide complex structures and 
layed down paths by which such can be attained, It simply provides a baseline to render the desire output and 
gives the freedom for the developer to determine how his/her application data flow  works.


## The Guide
In this guide, we simply will be looking at Gu is its only two possible representation 
or in essense, the two ways you will ever use its constructs, which are as a `Page` and as `Component`. 
This allows you to grasp the available spectrum and capabilities provided by Gu and 
to evolve and define for yourself how you wish to mix and match Gu into your projects and workflow.

*Gu has evolved over its development lifetime alot, loosing and adding new ideas into the way it works but 
I have ensured to keep the tenant of simplicity and a non-intrusive architecture, that greatly meet the rendering 
needs of the developer and also grant freedom in how it should be used with in projects.*

### A Page
The Page approach is pretty much as its called, a "Page".  Combining ideas from [Goa](https://goa.design/) in 
the way its structures are defined and generated, Gu's [Design Package](./designs) defines structures which 
unlike [Goa](https://goa.design/)  do not provide any form of code generation but produces the desired effect of defining with intent 
the content expected on a page. In a sense, it is the organizational structure when wanting to define multipage or 
single page applications with gu.

Basically a page is a resource amongs many resources which depending on the availability
of a predefined route to be validated against, will be rendered.  On the client side this means any resource which 
matches the current URL hash which gets rendered onto the browser DOM, while on the client it is the 
URL provided to generated a complete html response to render a full page 
with its differents parts (i.e head, links, scripts, styles and body tags).

Pages on the client listen for update requests from the things they render if this matches the library reaction interface, 
which effectively provides a easy but simply way  for developers to build reactivity to changes in structures.

With Pages in Gu, comes the concept of a ResourcesManager, this manager is created to managed and handle 
the response and rendering of all pages according to the current requested URI on the client and on the server
the provided URI. Generally a Resource/Page object, are not directly handled by the  developer has they are 
generated by the internals of  Gu's [Design Package](./designs) during initialization and runtime.  

As a note, what defines the criteria for which page or pages get rendered by the ResourcesManager is the routes 
to which this resources get pegged down to, if no route is provided then it is understood that the page is simply 
a part of any URI to be rendered. This is intentional but not advised has structurally and organization wise, resources 
should be self encapsulating of their entire components and parts.

Creating a page is rather simple has it requires the calling of the Resource function which embodies the 
content or intent of content for that page through the provided functions and structures Gu provides.

Below is an example of a page which a single Hello text printed on the page.

```go
package main

import (
  "github.com/gopherjs/gopherjs/js"
  . "github.com/influx6/gu/design"
  . "github.com/influx6/gu/trees"
  . "github.com/influx6/gu/trees/elems"
  . "github.com/influx6/gu/trees/events"
  . "github.com/influx6/gu/trees/property"
)

var _ = Resource(func() {

    DoTitle("Hello App")

    DoMarkup(func() *Markup {
      return Div(
        CSS(`
          ${
            width:100%;
            height: 100%;
          }

          $ h1 {
            font-size: {{ .Size }};
            text-align: center;
            margin: 20% 0  0 5%;
          }

          $ span {
            text-align: center;
            font-weight: bold;
            margin: 0 0 0 50%;
            color: rgba(0,0,0,0.5);
          }

          $ h1::after{
            content:"!";
            display: inline-block;
          }

          $ h1:hover::after{
            content:"*";
            color: red;
            display: inline-block;
          }

        `, struct{ Size string }{Size: "130px"}),
        IDAttr("hello"),
        Header1(
          Text("Hello"),
          ClickEvent(func(ev EventObject, tree *Markup) {
            js.Global.Call("alert", "I just got clicked, Yaay!!!")
          }, ""),
        ),
        Span(Text("Click me")),
      )
    }, "", false)

  })


func main(){
	New(&redom.DOMRenderer{
		Document: dom.GetWindow().Document(),
	}).Init(true)
}
```

Rendered Page:
![Image of Page](../../examples/hello/normal.png)

Rendered Page with Hover Effect:
![Image of Page with Hover](../../examples/hello/on-hover.png)

Rendered Page with clicked "Hello" text:
![Image of Page when clicked](../../examples/hello/on-click.png)

The code above flurishes with  declarations of  intent which when read fully describes the
outcome expected on the page. As stated within Gu, a Resource is a single page, which encapsulates
 what is expected with its logic and architecture which then gets rendered as a page based on the URI
 critieria.

We create a resource by calling the [Design Package](../../designs) `Resource` function which generates 
a function to be instantiated and executed by the managing `ResourcesManager` to create the resource.
It simple returns the index position which that resource will be located in within the `ResourcesManager`.
But this is usually not needed but also exists to allwo the pattern of declaration.

```go
var _ = Resource(func() {
    ....
})
```

The main function handles the creation of the `ResourcesManager` by calling the `New`
function from the [Design Package](../../designs) package. The `ResourcesManager` expects an an optional 
argument, which is a `ResourceRenderer` type to handle the rendering of the resources on the client.
The   `ResourceRenderer` if passed in will only be ever used on the client, to handle the automatic update of the DOM
during the initial load and continous updates request either by a component or the browsers URI.

```go
	New(&redom.DOMRenderer{
		Document: dom.GetWindow().Document(),
	}).Init(true)
```

**Note**: The `Init()` function is the core of a `ResourcesManager` to intialize all present `Resource` functions 
already loaded either as part of the package or from an externally imported package. Which brings me to the need to 
explain how the `New` works. The `design.Resource(func())` works by stacking the provided function in a global 
resource stack, when the `New` function is called to create a `ResourcesManager`, it takes all available functions 
added into the package resource stack, clearing out all. This is done to ensure only the `ResourcesManager` created
ever owns those resources. Generally there should ever be only one `ResourcesManager` created and passed to 
either your client or server code, has it works on either end.

We continue in the Resource function which immediately sets the route to be targeted for which this `Resource`
should be rendered, now this particular code is excluded in the example code but added here for breadth and also 
to provide the opportunity to showcase how a Resource is locked to a given URI, generally by the hash of the page.

```go
	UseRoute("/hello")
```

Next we set the title expected for the page, by calling the `DoTitle` function which ensures a `<title>`tag is included 
in the head, thereby setting the seen title when this is rendered.
```go
	DoTitle("Hello App")
```

The final piece the page is the simple markup we intently desire that the page display, which is a simple "Hello Text"
with a faded "Click Me!" below it.

```go
DoMarkup(func() *Markup {
      return Div(
        CSS(`
          ${
            width:100%;
            height: 100%;
          }

          $ h1 {
            font-size: {{ .Size }};
            text-align: center;
            margin: 20% 0  0 5%;
          }

          $ span {
            text-align: center;
            font-weight: bold;
            margin: 0 0 0 50%;
            color: rgba(0,0,0,0.5);
          }

          $ h1::after{
            content:"!";
            display: inline-block;
          }

          $ h1:hover::after{
            content:"*";
            color: red;
            display: inline-block;
          }

        `, struct{ Size string }{Size: "130px"}),
        IDAttr("hello"),
        Header1(
          Text("Hello"),
          ClickEvent(func(ev EventObject, tree *Markup) {
            js.Global.Call("alert", "I just got clicked, Yaay!!!")
          }, ""),
        ),
        Span(Text("Click me")),
      )
    }, "", false)
```

The `DoMarkup` function accepts three types of input:

  1. A `Markup` structure provided by the `trees`, `trees\elems` and `trees\property` packages.
  2. A function which returns a single or a slice/list of markup structures (When a list is returned it gets wrap in a section tag)
  3. A string which will be parsed to generate the markup structure representing it.

The use of a functional style allows us to easily and intently describe the structure 
for any markup combination and grants us the full power of functional Go.

The special item in all the structures provided is the `CSS` function which will 
take the style properties described into it and create a `<style>` that whoes content
is the string within and where all `$` characters are replaced by the parents unique 
UUID. This ensures that whatever properties are defined are enforced to only apply to 
the parent and its children.

The `DoMarkup` as well as an alternative function within the `gu/design` package,
called the `DoView`.

```go
type ReactiveSubscription interface {
	React(func())
}

type Reactive interface {
	ReactiveSubscription
	Publish()
}
```

The `DoView` provides an alternative which focus more on a region of markup which 
is dynamic and changes due to some operation, data or condition. The view automatically 
updates itself content based on the `Reactive` interface for any structure which meets 
that interface.

*The basic rules of choosing between `DoMarkup` and `DoView` is simply on the basis of 
whether the contents and its data are dynamic and dependent on some system, data or 
structure which changes and requires efficient update.*

```go
type Renderable interface {
	Render() *trees.Markup
}
```

The `DoView` expects as input on structures which matches the `Renderable` interface
and then passes those to build its markup output. If any of these structures implement 
the `Reactive` interface then it subscribes to listen for changes updates and updates 
the renderered content if on the client automatically. Which ensures such dynamic 
regions and data keep updated without any effort on the developers side.


### A Component
Component are the secondary system Gu caters to. Components are represented as views 
or regions of markup which are dynamic and change, even if they are not dynamic, they 
are region which are fed their markup by external structures that meet the `Renderable`
interface.

We will be building a simple email subscription app has displayed by the images below.
This example show cases well enough how components can be built with `Gu` and how 
communicating between components is highly decoupled and allows and ensures that 
each component encapsulates its markup and behaviour(i.e events, look and feel).

** Source Files are in [Subscribe Sample](../../examples/subscribe)**

Rendered Page:
![Image of Page](../../examples/subscribe/index.png)

Rendered Page when subscription passes:
![Image of Page When Passed](../../examples/subscribe/pass.png)

Rendered Page when subscription fails:
![Image of Page When Failed](../../examples/subscribe/failed.png)

The app is simple in that it requires entering an email address which is supposed
to added to the App mailing list and returns either a pass or failure as to the end 
result of such a subscription. In truth we won't be adding the functionality of calling 
an external API has this only demonstrates how components can be built but assurdedly 
the code will be completed on the basis of component creation and intercommunication.

When building the sample App, file structure wise things were arranged in an order 
which described best the contents and order in which the App was to be built.

![Expanded App File Structure](../../examples/subscribe/file-structure-full.png)

- The CSS style Rules

This are not components but sturctures provided by `Gu` which defines the css 
used by the components themselves in providing the styles that affect only those 
components and the page.

The css system which `Gu` provides combines the power of Go's `text/template` package
and a css parser to create a system that allows targeted styles which target the 
parent which it gets loaded into through which the `$` represents. This allows 
us the flexibility which markups can be influenced by css.

```go
import "github.com/influx6/gu/css"

csr := css.New(`

  $:hover {
    color: red;
  }

  $::before {
    content: "bugger";
  }

  $ div a {
    color: black;
    font-family: {{ .Font }}
  }

  @media (max-width: 400px){

    $:hover {
      color: blue;
      font-family: {{ .Font }}
    }

  }
`)

  sheet, err := csr.Stylesheet(struct {
    Font string
  }{
    Font: "Helvetica"
  }, "#galatica")


  sheet.String()

```

Like the above code, `Gu CSS` combines the power of Go templates to allow usage of  
context objects which can influence the value of a style property generated based 
on the value of the context's attributes. 


- The Subscriber component

This component defines the structure which defines how a subscription is collected.
It provides the necessary HTML structure, styles and events needed to create a fully 
functioning subscription input and submitter.

We import the packages which provides the functionality we need. A few are imported 
into the package using the `.` approach which allows us the use of the methods,
structures without using a package name alias and this is done for convenience and 
not a general rule or a advised rule.

```go
package app

import (
  "github.com/influx6/gu/dispatch"
  . "github.com/influx6/gu/trees"
  . "github.com/influx6/gu/trees/elems"
  . "github.com/influx6/gu/trees/events"
  . "github.com/influx6/gu/trees/property"
  "github.com/influx6/gu/css"
  "honnef.co/go/js/dom"
)
```

Next is defined a event type which will be used to communicate an event through 
the internal dispatch which allows communication of types across components. 
But this system is neither a rule and developers are free to define how their 
components communicate and behave. 

```go
// SubscriptionSubmitEvent defines a event sent out to define the status of a subscription
// event.
type SubscriptionSubmitEvent struct {
  Email  string `json:"email"`
  Status bool   `json:"status"`
}
```

```go
dispatch.Dispatch(SubscriptionSubmitEvent{
  Email:  input.Value,
  Status: true,
})
```

The `SubscriptionSubmitEvent` contains the email address and a status which 
defines if the subscription can be considered valid.


The component itself is called `Subscriber`, these defines a struct which implements 
the `Renderable` interface defined by Gu, which allows this structure the power to 
encapsulate its markup representation, behaviour and event expected. It as well 
has only a single attribute which allows customization of the color of the subscribe
submit button.

```go
// Subscriber defines the Subscriber component which renders a subscriber
// submission form which collects the data received and submits it to the API.
type Subscriber struct {
  SubmitBtnColor string
}
```

The `Render` function returns a instance of a pointer to a markup structure defined 
by Gu which allows functional composition of markup structures to define the expected
markup which will be generated for the component and more so the events which are expected
against particular markup and the action to which should be performed on that event.

```go
// SubscribeCSS defines the css component which defines the rendering for a
// subscriber form.
var SubscribeCSS = css.New(`
  $, $ *{
    box-sizing: border-box;
    -o-box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
  }

  $ {
    width: 100%;
    height: auto;
    margin: 0;
    padding: 0;
  }

  $.subscription {
    height: 70px;
    margin: 60px 0px 0px 0px;
  }

  $.subscription .form{
    width: 85%;
    height: 100%;
    margin: 0 auto;
    border: 1px solid rgba(0,0,0,0.3);
  }

  $.subscription .form .email, $.subscription .form .buttons {
    vertical-align: top;
    display: block;
  }

  $.subscription .form .email {
    width: 100%;
    height: 100%;
  }

  $.subscription .form .email input{
    width: 100%;
    height: 100%;
    outline: none;
    border: none;
    display: block;
    font-size: 1.3em;
    padding: 5px 10px;
  }

  $.subscription .form .buttons {
    display: block;
    width: 100%;
    height: 100%;
  }

  $.subscription .form .buttons button {
    outline: none;
    border: none;
    display: block;
    cursor: pointer;
    border: 1px solid rgba(26, 143, 187, 1); 
  }

  $.subscription .form .buttons .button.named {
    width: 100%;
    height: 100%;
    font-size: 1.0em;
    font-weight: bold;

    {{ if ne .SubmitBtnColor "" }}
    background: {{ .SubmitBtnColor }};
    {{ else }}
    background: #42b0da;
    {{ end }}

  }

  $.subscription .form .buttons .button.named {
    font-weight: bold;
    font-size: 1.7em;
  }

  @media (min-width:640px){

    $.subscription .form .email {
      width: 75%;
      display: inline-block;
    }

    $.subscription .form .buttons {
      width: 25%;
      display: inline-block;
    }

  }
`)

// Render returns the markup for the subscription component.
func (s *Subscriber) Render() *Markup {
  return Section(
    CSS(SubscribeCSS, s),
    ClassAttr("subscription"),
    Form(
      ClassAttr("form", "form-control"),
      Section(
        ClassAttr("email"),
        Input(
          PlaceholderAttr("example@mail.com"),
          TypeAttr("email"),
        ),
      ),
      Section(
        ClassAttr("buttons"),
        Button(
          Text("Subscribe"),
          ClassAttr("button", "named"),
          ClickEvent(func(event EventObject, tree *Markup) {
            event.PreventDefault()
            event.StopPropagation()

            doc := dom.GetWindow().Document()
            input, ok := doc.QuerySelector(".subscription .form .email input").(*dom.HTMLInputElement)

            if !ok {
              dispatch.Dispatch(SubscriptionSubmitEvent{
                Status: false,
              })

              return
            }

            dispatch.NavigateHash("/", "#subscriptions/submit", "#")

            dispatch.Dispatch(SubscriptionSubmitEvent{
              Email:  input.Value,
              Status: true,
            })

          }, ""),
        ),
      ),
    ),
  )
}
```

  Notably is this portion of its `Render` function which adds a CSS markup and 
  passes the subscriber as its context which allows us to effect the styles value 

```go
CSS(SubscribeCSS, s),
```

```go 
  $.subscription .form .buttons .button.named {
    width: 100%;
    height: 100%;
    font-size: 1.0em;
    font-weight: bold;

    {{ if ne .SubmitBtnColor "" }}
    background: {{ .SubmitBtnColor }};
    {{ else }}
    background: #42b0da;
    {{ end }}

  }
```  

- The Notifier component
 This component defines the structure which defines how the subscription notification 
 of success or failure. It provides the necessary HTML structure, styles and events 
 needed to create a fully functioning subscription input and submitter.

```go
package app

import (
  "fmt"
  "github.com/influx6/gu"
  "github.com/influx6/gu/dispatch"
  . "github.com/influx6/gu/trees"
  . "github.com/influx6/gu/trees/elems"
  . "github.com/influx6/gu/trees/property"
  "github.com/influx6/gu/css"
)

// SubmissionNotifier defines the handler which displays the notification on the success or
// failure of a subscription.
type SubmissionNotifier struct {
  gu.Reactive
  c SubscriptionSubmitEvent
}

// NewNotifier returns a new instance of a page email subscription notifier.
func NewNotifier() *SubmissionNotifier {
  sn := SubmissionNotifier{
    Reactive: gu.NewReactive(),
  }

  sn.start()
  return &sn
}

// starts begin listening for a SubmitNotification which gets displayed.
func (s *SubmissionNotifier) start() {
  dispatch.Subscribe(func(sme SubscriptionSubmitEvent) {
    fmt.Printf("Received submit %#v\n", sme)
    s.c = sme
    s.Publish()
  })
}

// NotificationCSS defines the css component which defines the rendering for
// a notification page.
var NotificationCSS = css.New(`
  $, $ *{
    box-sizing: border-box;
    -o-box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
  }

  $ {
    width: 800px; 
    height: 100px;
    margin:0px auto;
  }

  $ .submission.title {
    margin:90px auto;
    text-align: center;
  }

  $ .submission.content .header {
    margin:0px auto;
  }

  $ .submission.content h2{
    font-size: 10em;
    text-align: center;
    color: rgba(0,0,0,0.2);
  }

  $ .submission.content h2.failed{
    color: #ab3809;
  }

  $ .submission.content h2.passed{
    color: #8caf29;
  }

  $ .submission.content .desc{
    margin:50px auto auto auto;
    font-size: 2em;
    text-align: center;
  }

  $ .submission.content .desc .email{
    color: rgba(255,255,255,1);
    background: rgba(67, 164, 189, 0.87);
  }

`)

// Render returns the markup for the page which displays the end result of a
// subscription submission.
func (s *SubmissionNotifier) Render() *Markup {
  return Div(
    CSS(NotificationCSS, s),
    Header1(ClassAttr("submission", "title"), Text("App Subscription")),
    Section(
      ClassAttr("submission", "content"),
      MarkupWhen((s.c.Status && s.c.Email != ""), Header2(ClassAttr("header", "roboto", "passed"), Text("Done!")), Header2(ClassAttr("header", "roboto", "failed"), Text("Failed!"))),
      MarkupWhen(s.c.Email != "", Paragraph(
        ClassAttr("desc"),
        Text("Welcome "),
        Span(ClassAttr("email"), Text("%q", s.c.Email)),
        Text(" to the App."),
      ),
        Paragraph(
          ClassAttr("desc"),
          Text("We are sorry but subscription failed."),
        )),
    ),
  )
}
```

With this components we require pages built with the `Gu` Resources which allows 
us to organize the components into adequate routes which we can then render with.

In Gu components are not rendered only off themselves but exists to be rendered within
a `Resource`.

- Layout Resource

This resource will be rendered on all pages which we allows us to use it as a layout 
for other pages to inherit or be rendered along with.

```go
package pages

import (
  . "github.com/influx6/gu/design"
  . "github.com/influx6/gu/examples/subscribe/app"
  "github.com/influx6/gu/css"
)

// IndexCSS defines the css component which defines the rendering for
// a notification page.
var IndexCSS = css.New(`
  *{
    margin: 0;
    padding: 0;
    font-family: "Lato", "Open Sans",sans-serif;
  }

  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    width: 100%;
    margin: 0 auto;
    background: #efefef;
  }

  .roboto {
    font-family: "Roboto", "Lato", "helvetica";
  }
`)

var _ = Resource(func(){

  // Set the pages title tag.
  DoTitle("App Subscription Submission")

  // Add a link tag with the google fonts.
  DoLink("https://fonts.googleapis.com/css?family=Lato|Open+Sans|Roboto","stylesheet",false)

  // Add a style tag with the css as content for the page.
  DoStyle(IndexCSS, nil,false)
})
```

- Subscribe Resource
This handles the subscription page which is rendered as the root of the app, this 
encapsulates all the markup expected to be rendered within this page. What confines 
a resource only for a specific route is the `UseRoute` function provided by the 
`Gu/design` package, this sets the resource to only ever be considered for rendering
when either the path or hash matches the set path. Whether the full path or hash is used
is set by the resource manager.


```go
package pages

import (
  . "github.com/influx6/gu/design"
  . "github.com/influx6/gu/examples/subscribe/app"
  . "github.com/influx6/gu/trees/elems"
  . "github.com/influx6/gu/trees/property"
  "github.com/influx6/gu/css"
)

// RootCSS defines a css component which defines the page rendering styles.
var RootCSS = css.New(`
  $, $ *{
    box-sizing: border-box;
    -o-box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
  }

  $ {
    text-align: center;
    margin: 150px 0px;
  }

  $ h1 {
    color: rgba(0,0,0,0.7);
    font-size: 3em;
  }
`)

var _ = Resource(func() {

  UseRoute("#")

  DoMarkup(Div(
    CSS(RootCSS, nil),
    ClassAttr("root"),
    Header1(
      Text("Become A Subscriber"),
    ),
  ), "",false, false)

  DoView(&Subscriber{
    SubmitBtnColor: "",
  }, "", false, false)

})

```

In `Gu`, as mentioned before, two functions are used to define renderable regions,
the `DoMarkup` which handles rendering of static, non-dynamic or unchanging content
and the `DoView`. 

`DoView` defers from `DoMarkup` in that it creates a region within the DOM where 
based on the criteria that any registered change or notification change it receives
will cause the re-rendering of the region, updated the DOM has necessary and efficiently.
That means if you have a component or region which must be dynamic and update regularly 
then `DoView` is the right choice.

Also, the internal view system checks its arguments for any that implements the `Reactive`
interface and ensures to listen for change updates to cause DOM upates, these way, a level 
of reactivity is provided as well.

- Notification Page
This page contains the component which renders out the notification of the result 
of the subscription to the app. 

```go
package pages

import (
  . "github.com/influx6/gu/design"
  . "github.com/influx6/gu/examples/subscribe/app"
)

var _ = Resource(func(){

  UseRoute("#subscriptions/submit")

  notifier := NewNotifier()
  DoView(notifier, "", false, false)

})
```

It initializes a new Notifier and passes that to a the `DoView` function, these
creates a view which can be dynamically updated to update its content as explained earlier.


Once all resources have been created and contents organized as desired, then all that is left 
is to create a central Resource manager which handles all the registered resources.

Only resources loaded through import calls or defined within the same package as 
the app handle will be managed.

```go
package subscribe

import (
  "github.com/influx6/gu/app"
  _ "github.com/influx6/gu/examples/subscribe/pages"
)

var App = app.New()
```

The `App` variable becomes the central home of all loaded resources and provides 
methods to render the current resources by calling it's `Render` method with a 
required path. This is useful when rendering on the server but it actually 
automatically handles all update and rendering to the browser DOM on the client and 
requires no active settings.

Once the handle has been created then all that is left is to tell the ResourceManager
to initialize all resources and whether to use full paths or location hashes has 
its routing means. This is passed as a boolean value to the `Init` method. 

Here a true indicates usage of hash and a false indicates usage of full path of 
the location within the browser or the passed in path when rendering through
the `App.Render` method.

```go
func main(){
  App.Init(true)
}
```

