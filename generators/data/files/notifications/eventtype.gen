package {{.Package.Name}}

// {{.Struct.Object.Name}}Subscriber defines a interface that which is used to subscribe specifically for 
// events  {{.Struct.Object.Name}} type.
type {{.Struct.Object.Name}}Subscriber interface{
    Receive({{.Struct.Object.Name}})
}

// {{.Struct.Object.Name}}Notification defines a structure type which must be used to 
// receive {{.Struct.Object.Name}} type has a event.
type {{.Struct.Object.Name}}Notification struct{
    sml sync.Mutex
    subs []{{.Struct.Object.Name}}Subscriber
    register map[{{.Struct.Object.Name}}Subscriber]
}

// UnNotify removes the given subscriber from the notification's list if found from future events.
func (sn *{{.Struct.Object.Name}}Notification) UnNotify(sub {{.Struct.Object.Name}}Subscriber){
    sn.do(func(){
        index, ok := sn.register[sub]
        if !ok {
            return
        }

        sn.subs = append(sn.subs[:index], sn.subs[index+1:]...)
    })
}

// Notify adds the given subscriber into the notification list and will await an update of 
// a new event of the given {{.Struct.Object.Name}} type.
func (sn *{{.Struct.Object.Name}}Notification) Notify(sub {{.Struct.Object.Name}}Subscriber){
    sn.do(func(){
        sn.register[sub] = len(sn.subs)
        sn.subs = append(sn.subs, sub)
    })
}

// Handle takes the giving value and asserts the expected value to be of 
// the type and pass on to it's underline subscribers else ignoring the event.
func (sn *{{.Struct.Object.Name}}Notification) Handle(elem interface{}){
    sn.do(func(){
        for _, sub := range sn.subs {
            sn(elem)
        }
    })
}

// do performs action with the mutex locked and unlocked appropriately, ensuring safe 
// concurrent access.
func (sn *{{.Struct.Name}}Notification) do(fn func()){
    if fn == nil {
        return nil
    }

    sn.sml.Lock()
    defer sn.sml.Unlock()

    fn()
}